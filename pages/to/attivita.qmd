---
title: "Trappolaggio"
description: "Riassunto dell'attività di trappolaggio per settore"
lang: it-IT
format: dashboard
---

```{r setup, include=FALSE}
source("../../scripts/importQfieldCloud.R")
source("../../scripts/calcoliTrappole.R")
library(tidyr)
library(dplyr)
library(ggplot2)
library(plotly)
library(leaflet)

```

# Trappole

Attualmente su `r nrow(trap)` trappole posate sono attive `r nrow(trap[attive,])` trappole, di queste `r nrow(trap[controllate,])` sono state controllate negli ultimi `r giorniXcontrollata` giorni.

```{r tabellaBuffer, echo=FALSE, warning=FALSE}
# tabella con il numero di trappole per classi di distanza dal nido più vicino
tabTrapBuffer <- data.frame(
  distanza = attributes(table(
    cut(
      trap$distanzaNido,
      breaks = c(0, buffer$distance, Inf),
      dig.lab = 7
    )
  ))$dimnames[[1]],
  totali = as.integer(table(cut(
    trap$distanzaNido,
    breaks = c(0, buffer$distance, Inf)
  ))),
  attive = as.integer(table(cut(
    trap$distanzaNido[attive],
    breaks = c(0, buffer$distance, Inf)
  ))),
  controllate = as.integer(table(cut(
    trap$distanzaNido[controllate],
    breaks = c(0, buffer$distance, Inf)
  )))
)

tabTrapBuffer <- rbind(
  tabTrapBuffer,
  data.frame(
    distanza = "Totale",
    totali = sum(tabTrapBuffer$totali),
    attive = sum(tabTrapBuffer$attive),
    controllate = sum(tabTrapBuffer$controllate)
  )
  
)

#tabTrapBuffer

knitr::kable(tabTrapBuffer, format = "html", caption = "Numero di trappole per classi di distanza dal nido più vicino; attive sono le trappole non rimosse, controllate sono le trappole non rimosse e controllate almeno una volta negli ultimi 30 giorni")

```

```{r tabellaDensitaBuffer, echo=FALSE, warning=FALSE}
# tabella con la densità di trappole per km2 nelle aree buffer
#numero di trappole per buffer
tabDensity <- data.frame(
  distanza = buffer$distance,
  n = buffer$nTrappoleControllate,
  area = round(buffer$area, 2),
  densita = round(buffer$densita, 2)
  
)

knitr::kable(tabDensity, format = "html", caption = "Densità di trappole controllate per km2 nelle aree buffer")

```

# Controlli

## Column {width=60%}

```{r graficoTrappoleMese, echo=FALSE, warning=FALSE}
#| label: graficoTrappoleMese
#| title: Numero di trappole posizionate per mese
#| description: Grafico a barre del numero di trappole posate per mese
#| output: plotly
#| fig.width: 10
#| fig.height: 6
#| fig.align: center
#| fig.cap: Numero di trappole posate per mese
#| fig.link_text: Visualizza il grafico a tutto schermo
#| fig.link_url: https://plotly.com/~giorgio.guarnera/1/
#| fig.show_link: true
#| fig.save: true
#| fig.filename: trappoleMese
#| 

# grafico a barre del numero di trappole aggiunte nel periodo, cut per mese

trap$Data.posizionamento <- as.Date(trap$Data.posizionamento, origin = "1970-01-01")

trap$AnnoMese <- format(trap$Data.posizionamento, "%Y-%m")

periodo <- min(trap$Data.posizionamento):max(trap$Data.posizionamento)
periodo <- as.Date(periodo, origin = "1970-01-01")
periodo <- format(periodo, "%Y-%m")
periodo <- levels(as.factor(periodo))


tab <- as.data.frame(table(trap$AnnoMese))
colnames(tab) <- c("AnnoMese", "freq")
tab$AnnoMese <- as.character(tab$AnnoMese)

tab <- complete(tab, AnnoMese = periodo, fill=list(freq = 0))

plot_ly(tab, x = ~AnnoMese, y =~freq, colors = "gold") %>%
  add_bars() %>%
  layout(
         xaxis = list(title = "Mese"),
         yaxis = list(title = "Numero di trappole")
         )





```

<!--  grafico a barre del numero di controlli per mese -->

```{r graficoControlliMese, echo=FALSE, warning=FALSE}
#| label: graficoControlliMese
#| title: Numero di controlli per mese
#| description: Grafico a barre del numero di controlli per mese
#| output: plotly
#| fig.width: 10
#| fig.height: 6
#| fig.align: center
#| fig.cap: Numero di controlli per mese

controlli$Data <- as.Date(controlli$data, origin = "1970-01-01")

controlli$Mese <- format(controlli$Data, "%m")
controlli$Anno <- format(controlli$Data, "%Y")
controlli$AnnoMese <- paste(controlli$Anno, controlli$Mese, sep = "-")
controlli$AnnoMese <- as.factor(controlli$AnnoMese)
 
periodo <- min(controlli$data):max(controlli$data)
periodo <- as.Date(periodo, origin = "1970-01-01")
periodo <- format(periodo, "%Y-%m")
periodo <- levels(as.factor(periodo))


tab <- as.data.frame(table(controlli$AnnoMese))
colnames(tab) <- c("AnnoMese", "nControlli")
tab$AnnoMese <- as.character(tab$AnnoMese)

tab <- complete(tab, AnnoMese = periodo, fill=list(nControlli = 0))

plot_ly(tab, x = ~AnnoMese, y =~nControlli, colors = "blue") %>%
  add_bars() %>%
  layout(
         xaxis = list(title = "Mese"),
         yaxis = list(title = "Numero di controlli")
         )

# q: how to change the color of the bars?
# a: 


```

## Column {width=40%}

<!-- istogramma per mesi intervallo di controllo -->

```{r graficoIntervalloControllo, echo=FALSE, warning=FALSE}
#| label: graficoIntervalloControllo
#| title: Intervallo di controllo
#| description: Istogramma dell'intervallo di controllo
#| output: plotly
#| fig.width: 10
#| fig.height: 6
#| fig.align: center
#| fig.cap: Intervallo di controllo
#| fig.link_text: Visualizza il grafico a tutto schermo
#| fig.link_url: https://plotly.com/~giorgio.guarnera/1/
#| fig.show_link: true
#| fig.save: true
#| fig.filename: intervalloControllo
#| fig.ext: html
#| fig.keep_md: false
#| fig.keep_html: false
#| fig.keep_pdf: false
#| fig.keep_eps: false
#| fig.keep_svg: false
#| fig.keep_png: true
#| fig.keep_jpg: false
#| fig.keep_json: false
#| fig.keep_csv: true
#| fig.keep_xlsx: true

# boxplot dell'intervallo di controllo per mese-anno

controlli$AnnoMese <- format(controlli$Data, "%Y-%m")
controlli$intervallo <- as.numeric(controlli$intervallo)

plot_ly(controlli, x = ~AnnoMese, y = ~intervallo, type = "box") %>%
  layout(
         xaxis = list(title = "Mese"),
         yaxis = list(title = "Intervallo di controllo (giorni)")
         )

```

<!-- tabelle media intervalli per mese -->

```{r tabellaMediaIntervallo, echo=FALSE, warning=FALSE}
# tabella con la media, mediana e moda dell'intervallo di controllo per mese
# calcolo della media, mediana e moda dell'intervallo di controllo per mese

tabMediaIntervallo <- controlli %>%
  group_by(AnnoMese) %>%
  summarise(
    media = mean(intervallo, na.rm = T),
    mediana = median(intervallo, na.rm = T),
    moda = as.numeric(names(sort(-table(intervallo))[1]))
  )

knitr::kable(tabMediaIntervallo, format = "html", caption = "Media, mediana e moda dell'intervallo di controllo per mese")

```

# Catture

## Column {width=50%}

```{r graficoCattureMese, echo=FALSE, warning=FALSE}
#| label: graficoCattureMese
#| title: Numero di catture dei diversi taxa per mese
#| description: Grafico a barre del numero di catture per mese
#| output: plotly
#| fig.width: 10
#| fig.height: 6
#| fig.align: center
#| fig.cap: Numero di catture per mese
#| fig.link_text: Visualizza il grafico a tutto schermo

# grafico a barre dinamico con possibilità di selezionare le colonne (taxon) da visualizzare
# ogni barra è costituita dal numero di trappole che hanno catturato almeno un individuo di quel taxon e dalle trappole che non hanno catturato nulla

controlliGeoTemp <- controlliGeo[, c( taxa$colonne, "Manomissione", "fori", "AnnoMeseMedioCattura")]

# unique(controlliGeoTemp$AnnoMeseMedioCattura)

# elimino i controlli con manomissione
controlliGeoTemp$Manomissione <- as.logical(controlliGeoTemp$Manomissione)
controlliGeoTemp <- controlliGeoTemp[controlliGeoTemp$Manomissione == FALSE | is.na(controlliGeoTemp$Manomissione),]

# creo dataframe con il numero di catture positive per ogni taxon per mese
cattureTF <- controlliGeoTemp[!is.na(controlliGeoTemp$AnnoMeseMedioCattura),] %>%
  group_by(AnnoMeseMedioCattura) %>%
  summarise(
    across(
      .cols = taxa$colonne,
      .fns = ~ sum(.x > 0, na.rm = T)
    )
  ) %>%
  st_drop_geometry() %>%

# complete the dataframe with the months with no cattures
complete(AnnoMeseMedioCattura = periodo, fill = mapply(function(x,y) { y }, taxa$colonne, rep(0, length(taxa$colonne)), SIMPLIFY = FALSE,USE.NAMES = TRUE)) # soluzione per creare la lista di zeri nominata: https://stackoverflow.com/posts/17842875/revisions


# creo dataframe con il controlli negativi per ogni taxon per mese
controlliTF <- controlliGeoTemp[!is.na(controlliGeoTemp$AnnoMeseMedioCattura),] %>%
  group_by(AnnoMeseMedioCattura) %>%
  summarise(
    across(
      .cols = taxa$colonne,
      .fns = ~ sum(.x == 0, na.rm = T)
    )
  ) %>%
  st_drop_geometry() %>%
  # complete the dataframe with the months with no captures
  complete(AnnoMeseMedioCattura = periodo, fill = mapply(function(x,y) { y }, taxa$colonne, rep(0, length(taxa$colonne)), SIMPLIFY = FALSE,USE.NAMES = TRUE)) # soluzione per creare la lista di zeri nominata: https://stackoverflow.com/posts/17842875/revisions

# unisco i due dataframe
# aggiunta colonna tipo per distinguere tra catture e non catture
controlliTF$tipo <- "non catture"
cattureTF$tipo <- "catture"

cattureTF <- rbind(cattureTF, controlliTF)

rm(catture, controlliTF)

# plotly


# grafico a barre con plotly con il numero di controlli che hanno catturato almeno un individuo di quel taxon e dei controlli che non ne hanno catturati, con possibilità di selezionare le colonne (taxon) da visualizzare
# 
# ogni barra è costituita dal numero di controlli che hanno catturato almeno un individuo di quel taxon e dai controlli che non hanno catturato nulla

p <- plot_ly(data = cattureTF, x = ~AnnoMeseMedioCattura, y = ~get(taxa$colonne[1]), color =  ~tipo, colors = c("red", "green"), type ="bar")

# # Add traces for the remaining y-variables

p <- p %>% add_trace(y = ~Vespa_crabro_tot, visible = FALSE)
p <- p %>% add_trace(y = ~altri_Vespidae, visible = FALSE)
p <- p %>% add_trace(y = ~Apis.mellifera, visible = FALSE)
p <- p %>% add_trace(y = ~Bombus.sp., visible = FALSE)
p <- p %>% add_trace(y = ~Altri_Anthophila, visible = FALSE)
p <- p %>% add_trace(y = ~Lepidoptera, visible = FALSE)
p <- p %>% add_trace(y = ~Sirphidae, visible = FALSE)
p <- p %>% add_trace(y = ~Diptera, visible = FALSE)
p <- p %>% add_trace(y = ~Altro, visible = FALSE)


# q: can you create add_trace without a loop?
# a: yes, you can create add_trace without a loop
# q: can you code it for me?
# 




# p <- layout(p, barmode = "stack")
# p
dropDown <- list()
for(i in 1:nrow(taxa)){
  visibilities <- rep(FALSE, nrow(taxa))
  visibilities[i] <- TRUE
  visibilities <- as.vector(matrix(rep(visibilities, 2), 2, nrow(taxa), byrow = T ))
  dropDown[[i]] <- list(
    method = "update",
    args = list(
      list(visible = visibilities),
      list(title = taxa$etichette[i])
    ),
    label = taxa$etichette[i]
  )
}

# Add layout to include the dropdown menu

p <- p %>%
  layout(
    xaxis = list(title = "mesi"),  # Custom x-axis label
    yaxis = list(title = "controlli"),   # Custom y-axis label
    updatemenus = list(
      list(
        type = "dropdown",
        x = 0.2,
        y = 1.1,
        showactive = TRUE,
        buttons = dropDown
      )
    ),
    barmode = "stack"
  )

p





```

## Column {width=50%}

<!-- carta leaflet con i punti di cattura di Vespa velutina -->

```{r mappaCatture, echo=FALSE, warning=FALSE}
# mappa con i punti di cattura di Vespa velutina
# 
# seleziono solo i controlli con cattura di Vespa velutina
cattureVespa <- controlliGeo[controlliGeo$Vespa_velutina_tot > 0,]
cattureVespa <- st_transform(cattureVespa, crs = 4326)
nidi <- st_transform(nidi, crs = 4326)

leaflet() %>%
  addProviderTiles("OpenStreetMap.Mapnik") %>%
  addCircleMarkers(data = cattureVespa, radius = 4, color = "black", weight = 1, fillOpacity = 1, fillColor = "yellow", group = "catture") %>%
  addCircleMarkers(data = nidi, radius = 4, color = "black", weight = 1, fillOpacity = 1, fillColor = "red", group = "nidi") %>%
# addLegend("bottomright", colors = c("green", "orange", "red", "white"), labels = c("meno di 14 giorni", "tra 14 e 21 giorni", "più di 21 giorni", "rimosse"), title = "Ultimo controllo") %>%
  addLayersControl(overlayGroups = c("catture", "nidi"),
                          options = layersControlOptions(collapsed = FALSE)
                          ) %>%
  hideGroup("zone")

```
